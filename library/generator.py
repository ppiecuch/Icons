#!env python3

import os
import glob
import subprocess
import re
import json
import shutil
import zipfile
import urllib.request
from datetime import datetime

bootstrap_library_template = '''/* Auto Generated by {generator} on {date} */

#ifndef LIB_BOOTSTRAP_{STYLE}_{size}_H
#define LIB_BOOTSTRAP_{STYLE}_{size}_H

#include <string>
#include <stdexcept>

#include "lib_svgiconlist.h"

extern const char *svg_bootstrap_style_{style}_size_{size}[];

class Bootstrap{Style}{size}IconList : public SVGIconList {{

    static const int c_icon_count = {count};
    QColor m_fillColor = clNone;

public:
    int getCount() const override {{ return c_icon_count; }}

    QString getName(int index) const override {{
        if (index < 0 || index >= c_icon_count)
            throw std::out_of_range("Requested icon index is out of range");
        return QString::fromUtf8(svg_bootstrap_style_{style}_size_{size}[index]);
    }}

    QString getBody(int index) const override {{
        if (index < 0 || index >= c_icon_count)
            throw std::out_of_range("Requested icon index is out of range");
        return qReadAll(QString(":/svg/content/svg_bootstrap_style={style}_size={size}@%1.svg").arg(index));
    }}

    QString getSource(int index) const override {{
        if (index < 0 || index >= c_icon_count)
            throw std::out_of_range("Requested icon index is out of range");
        QString sColor;
        if (m_fillColor != clNone)
            sColor = QString(" fill=\\"%1\\"").arg(m_fillColor.name());
        return QString("<svg viewBox=\\"0 0 {size} {size}\\" xmlns=\\"http://www.w3.org/2000/svg\\">")
            + getBody(index).replace(" fill=\\"#212121\\"", sColor)
            + QString("</svg>");
    }}

    QColor getFillColor() const override {{ return m_fillColor; }}
    void setFillColor(QColor value) override {{ m_fillColor = value; }}

    QString getLibraryName() const override {{ return "Bootstrap {Style} {size}"; }}
    int getBaseSize() const override {{ return {size}; }}
}};

#endif // LIB_BOOTSTRAP_{STYLE}_{size}_H
'''

tabler_library_template = '''/* Auto Generated by {generator} on {date} */

#ifndef LIB_TABLER_{STYLE}_{size}_H
#define LIB_TABLER_{STYLE}_{size}_H

#include <string>
#include <stdexcept>

#include "lib_svgiconlist.h"

extern const char *svg_tabler_style_{style}[];

class Tabler{Style}{size}IconList : public SVGIconList {{

    static const int c_icon_count = {count};
    QColor m_fillColor = clNone;

public:
    int getCount() const override {{ return c_icon_count; }}

    QString getName(int index) const override {{
        if (index < 0 || index >= c_icon_count)
            throw std::out_of_range("Requested icon index is out of range");
        return QString::fromUtf8(svg_tabler_style_{style}[index]);
    }}

    QString getBody(int index) const override {{
        if (index < 0 || index >= c_icon_count)
            throw std::out_of_range("Requested icon index is out of range");
        return qReadAll(QString(":/svg/content/svg_tabler_style={style}@%1.svg").arg(index));
    }}

    QString getSource(int index) const override {{
        if (index < 0 || index >= c_icon_count)
            throw std::out_of_range("Requested icon index is out of range");
        QString colorStr = (m_fillColor == clNone) ? "currentColor" : m_fillColor.name();
        QString fillAttr = (m_fillColor == clNone) ? "" : QString(" fill=\\"%1\\"").arg(m_fillColor.name());
        QString body = getBody(index);
        body.replace("currentColor", colorStr, Qt::CaseInsensitive);
        return QString("<svg viewBox=\\"0 0 {size} {size}\\" xmlns=\\"http://www.w3.org/2000/svg\\"><g%1>%2</g></svg>")
            .arg(fillAttr, body);
    }}

    QColor getFillColor() const override {{ return m_fillColor; }}
    void setFillColor(QColor value) override {{ m_fillColor = value; }}

    QString getLibraryName() const override {{ return "Tabler {Style} {size}"; }}
    int getBaseSize() const override {{ return {size}; }}
}};

#endif // LIB_TABLER_{STYLE}_{size}_H
'''

fluent_library_template = '''/* Auto Generated by {generator} on {date} */

#ifndef LIB_FLUENT_{STYLE}_{size}_H
#define LIB_FLUENT_{STYLE}_{size}_H

#include <string>
#include <stdexcept>

#include "lib_svgiconlist.h"

extern const char *svg_fluent_style_{style}_size_{size}[];

class Fluent{Style}{size}IconList : public SVGIconList {{

    static const int c_icon_count = {count};
    QColor m_fillColor = clNone;

public:
    int getCount() const override {{ return c_icon_count; }}

    QString getName(int index) const override {{
        if (index < 0 || index >= c_icon_count)
            throw std::out_of_range("Requested icon index is out of range");
        return QString::fromUtf8(svg_fluent_style_{style}_size_{size}[index]);
    }}

    QString getBody(int index) const override {{
        if (index < 0 || index >= c_icon_count)
            throw std::out_of_range("Requested icon index is out of range");
        return qReadAll(QString(":/svg/content/svg_fluent_style={style}_size={size}@%1.svg").arg(index));
    }}

    QString getSource(int index) const override {{
        if (index < 0 || index >= c_icon_count)
            throw std::out_of_range("Requested icon index is out of range");
        QString fillAttr = (m_fillColor == clNone) ? "" : QString(" fill=\\"%1\\"").arg(m_fillColor.name());
        return QString("<svg viewBox=\\"0 0 {size} {size}\\" xmlns=\\"http://www.w3.org/2000/svg\\">")
            + getBody(index).replace(" fill=\\"#212121\\"", fillAttr)
            + QString("</svg>");
    }}

    QColor getFillColor() const override {{ return m_fillColor; }}
    void setFillColor(QColor value) override {{ m_fillColor = value; }}

    QString getLibraryName() const override {{ return "Fluent {Style} {size}"; }}
    int getBaseSize() const override {{ return {size}; }}
}};

#endif // LIB_FLUENT_{STYLE}_{size}_H
'''

breeze_library_template = '''/* Auto Generated by {generator} on {date} */

#ifndef LIB_BREEZE_{GROUP}_{size}_H
#define LIB_BREEZE_{GROUP}_{size}_H

#include <string>
#include <stdexcept>

#include "lib_svgiconlist.h"

extern const char *svg_breeze_size_{size}_group_{group}[];

class Breeze{Group}{size}IconList : public SVGIconList {{

    static const int c_icon_count = {count};
    QColor m_fillColor = clNone;

public:
    int getCount() const override {{ return c_icon_count; }}

    QString getName(int index) const override {{
        if (index < 0 || index >= c_icon_count)
            throw std::out_of_range("Requested icon index is out of range");
        return QString::fromUtf8(svg_breeze_size_{size}_group_{group}[index]);
    }}

    QString getBody(int index) const override {{
        if (index < 0 || index >= c_icon_count)
            throw std::out_of_range("Requested icon index is out of range");
        return qReadAll(QString(":/svg/content/svg_breeze_size={size}_group={group}@%1.svg").arg(index));
    }}

    QString getSource(int index) const override {{
        if (index < 0 || index >= c_icon_count)
            throw std::out_of_range("Requested icon index is out of range");
        QString body = getBody(index);
        if (m_fillColor != clNone) {{
            // Replace stroke colors for Breeze icons
            body.replace("currentColor", m_fillColor.name(), Qt::CaseInsensitive);
        }}
        return QString("<svg viewBox=\\"0 0 {size} {size}\\" xmlns=\\"http://www.w3.org/2000/svg\\">%1</svg>").arg(body);
    }}

    QColor getFillColor() const override {{ return m_fillColor; }}
    void setFillColor(QColor value) override {{ m_fillColor = value; }}

    QString getLibraryName() const override {{ return "Breeze {Group} {size}"; }}
    int getBaseSize() const override {{ return {size}; }}
}};

#endif // LIB_BREEZE_{GROUP}_{size}_H
'''

oxygen_library_template = '''/* Auto Generated by {generator} on {date} */

#ifndef LIB_{COLLECTION}_{size}_H
#define LIB_{COLLECTION}_{size}_H

#include <QCoreApplication>
#include <QResource>
#include <QMap>
#include <QStringList>
#include <stdexcept>

#include "../lib_svgiconlist.h"

extern const char *png_{collection}_size_{size}[];
extern const char *png_{collection}_size_{size}_aliases[][2];
extern const int png_{collection}_size_{size}_alias_count;

class {Collection}{size}IconList : public BitmapIconList {{
    static const int c_icon_count = {count};
    bool m_grayscale = false;
    static bool s_rccLoaded;
    mutable QMap<QString, QStringList> m_aliasCache;
    mutable bool m_aliasCacheBuilt = false;

public:
    int getCount() const override {{ return c_icon_count; }}

    QString getName(int index) const override {{
        if (index < 0 || index >= c_icon_count)
            throw std::out_of_range("Requested icon index is out of range");
        return QString::fromUtf8(png_{collection}_size_{size}[index]);
    }}

    QPixmap getPixmap(int index) const override {{
        if (index < 0 || index >= c_icon_count)
            throw std::out_of_range("Requested icon index is out of range");
        loadRcc();
        QString path = QString(":/{collection}/{size}/%1.png").arg(getName(index));
        QPixmap pix(path);
        if (m_grayscale)
            return BitmapIconList::toGrayscale(pix);
        return pix;
    }}

    QStringList getAliases(int index) const override {{
        if (index < 0 || index >= c_icon_count)
            return QStringList();
        buildAliasCache();
        return m_aliasCache.value(getName(index));
    }}

    bool isGrayscale() const override {{ return m_grayscale; }}
    void setGrayscale(bool value) override {{ m_grayscale = value; }}

    QString getLibraryName() const override {{ return "{display_name} {size}"; }}
    int getBaseSize() const override {{ return {size}; }}

    QList<int> getAvailableSizes() const override {{ return {{{sizes_list}}}; }}

private:
    static void loadRcc() {{
        if (!s_rccLoaded) {{
            QString rccPath = QCoreApplication::applicationDirPath() + "/../Resources/{rcc_name}.rcc";
            if (!QResource::registerResource(rccPath)) {{
                // Try relative path for development
                rccPath = "library/bitmap/{rcc_name}.rcc";
                QResource::registerResource(rccPath);
            }}
            s_rccLoaded = true;
        }}
    }}

    void buildAliasCache() const {{
        if (m_aliasCacheBuilt) return;
        for (int i = 0; i < png_{collection}_size_{size}_alias_count; ++i) {{
            QString alias = QString::fromUtf8(png_{collection}_size_{size}_aliases[i][0]);
            QString target = QString::fromUtf8(png_{collection}_size_{size}_aliases[i][1]);
            m_aliasCache[target].append(alias);
        }}
        m_aliasCacheBuilt = true;
    }}
}};

// Static member definition (place in one .cpp file if using multiple TUs)
inline bool {Collection}{size}IconList::s_rccLoaded = false;

#endif // LIB_{COLLECTION}_{size}_H
'''


def download_file(url, dest_path):
    """Download a file from URL if it doesn't exist."""
    if os.path.exists(dest_path):
        print(f"  File already exists: {dest_path}")
        return True
    print(f"  Downloading {url}...")
    try:
        urllib.request.urlretrieve(url, dest_path)
        print(f"  Downloaded to {dest_path}")
        return True
    except Exception as e:
        print(f"  Failed to download: {e}")
        return False


def extract_zip(zip_path, extract_dir):
    """Extract a ZIP file if not already extracted."""
    # Look for what's actually inside the zip
    with zipfile.ZipFile(zip_path, 'r') as zip_ref:
        # Get the top-level directory from the archive
        names = zip_ref.namelist()
        if names:
            top_folder = names[0].split('/')[0]
            expected_path = os.path.join(extract_dir, top_folder)
            if os.path.exists(expected_path):
                print(f"  Already extracted: {expected_path}")
                return expected_path
            print(f"  Extracting {zip_path}...")
            zip_ref.extractall(extract_dir)
            print(f"  Extracted to {expected_path}")
            return expected_path
    return None


def pull_git_repository(repo_url, repo_dir):
    if not os.path.exists(repo_dir):
        subprocess.run(["git", "clone", "--depth=1", "--no-single-branch", repo_url, repo_dir], check=True)
    else:
        subprocess.run(["git", "-C", repo_dir, "pull"], check=True)


def get_output_file_base(library: str, style: str = None, size: str = None, group: str = None):
    assert (library)
    name = f"svg_{library}"
    if style:
        name += f"_style={style}"
    if size:
        name += f"_size={size}"
    if group:
        name += f"_group={group}"
    return name


def get_output_var_base(library: str, style: str = None, size: str = None, group: str = None):
    assert (library)
    name = f"svg_{library}"
    if style:
        name += f"_style_{style}"
    if size:
        name += f"_size_{size}"
    if group:
        name += f"_group_{group}"
    return name


def scan_for_svg_files(icon_folder):
    svg_files = []
    for root, dirs, files in os.walk(icon_folder):
        for file in files:
            if file.endswith(".svg"):
                svg_files.append(os.path.join(root, file))
    return svg_files


def extract_svg_content(svg_file):
    with open(svg_file, 'r') as file:
        content = file.read()
    # Remove the <svg tag and extract the content
    content = re.sub(r'<svg[^>]*>', '', content)
    content = re.sub(r'</svg>', '', content)
    return content.strip()


def save_output(var: str, output_file_base: str, svg_contents, svg_basenames):
    for idx, content in enumerate(svg_contents):
        with open(f"content/{output_file_base}@{idx}.svg", 'w') as file:
            file.write(content)

    with open(f"{output_file_base}.c", 'w') as file:
        file.write('#include <stddef.h>\n\n')
        file.write('const char* %s[] = {\n' % var)
        for basename in svg_basenames:
            file.write(f'    "{basename}",\n')
        file.write('    NULL\n')
        file.write('};\n')

    return [f"{output_file_base}.c"]


def save_svg_iconlist(template: str, output_file_base: str, values: dict):
    with open(f"{output_file_base}.h", 'w') as file:
        for k, v in values.items():
            # Replace lowercase placeholder
            template = template.replace("{%s}" % k, str(v))
            # Replace Title case placeholder (e.g., {Style} -> Regular)
            template = template.replace("{%s}" % k.title(), str(v).title())
            # Replace UPPERCASE placeholder (e.g., {STYLE} -> REGULAR)
            template = template.replace("{%s}" % k.upper(), str(v).upper())
        # Convert escaped braces to actual braces
        template = template.replace("{{", "{").replace("}}", "}")
        file.write(template)


def main_bootstrap():
    repo_url = "https://github.com/twbs/icons"
    library = "bootstrap"

    repo_dir = "." + library
    icon_folder = os.path.join(repo_dir, "icons")

    meta = {'library': library, 'output': [], 'sizes': [16], 'styles': ['regular', 'fill']}
    pull_git_repository(repo_url, repo_dir)
    svg_all_files = scan_for_svg_files(icon_folder)
    for size in meta['sizes']:
        for style in meta['styles']:
            if style == 'regular':
                # Regular icons: files NOT ending with -fill.svg
                svg_files = [f for f in svg_all_files if not f.endswith("-fill.svg")]
            else:
                # Fill icons: files ending with -fill.svg
                svg_files = [f for f in svg_all_files if f.endswith("-fill.svg")]

            # Sort files alphabetically for consistent ordering
            svg_files.sort(key=lambda f: os.path.basename(f).lower())
            svg_contents = [extract_svg_content(svg_file) for svg_file in svg_files]
            svg_basenames = [os.path.splitext(os.path.basename(svg_file))[0] for svg_file in svg_files]
            output_var_base = get_output_var_base(library, style=style, size=size)
            output_file_base = get_output_file_base(library, style=style, size=size)
            meta['output'].extend(save_output(output_var_base, output_file_base, svg_contents, svg_basenames))

            save_svg_iconlist(bootstrap_library_template,
                              f"lib_bootstrap_{style}_{size}",
                              {'size': size, 'style': style, 'count': len(svg_contents), 'generator': os.path.basename(__file__), 'date': datetime.today().strftime('%Y-%m-%d %H:%M:%S')})

            print(f"SVG contents saved to {output_file_base}")

    return meta


def main_tabler():
    repo_url = "https://github.com/tabler/tabler-icons"
    library = "tabler"

    repo_dir = "." + library
    pull_git_repository(repo_url, repo_dir)

    meta = {'library': library, 'output': [], 'sizes': [24], 'styles': ["filled", "outline"]}
    for size in meta['sizes']:
        for style in meta['styles']:
            icon_folder = os.path.join(repo_dir, "icons", style)
            output_file_base = get_output_file_base(library, style=style)
            output_var_base = get_output_var_base(library, style=style)

            svg_files = scan_for_svg_files(icon_folder)
            # Sort files alphabetically for consistent ordering
            svg_files.sort(key=lambda f: os.path.basename(f).lower())
            svg_contents = [extract_svg_content(svg_file) for svg_file in svg_files]
            svg_basenames = [os.path.splitext(os.path.basename(svg_file))[0] for svg_file in svg_files]
            meta['output'].extend(save_output(output_var_base, output_file_base, svg_contents, svg_basenames))

            save_svg_iconlist(tabler_library_template,
                              f"lib_tabler_{style}_{size}",
                              {'size': size, 'style': style, 'count': len(svg_contents), 'generator': os.path.basename(__file__), 'date': datetime.today().strftime('%Y-%m-%d %H:%M:%S')})

            print(f"SVG contents saved to {output_file_base}/{output_var_base}")

    return meta


def run_fluent_importer(repo_dir: str):
    with open(os.path.join(repo_dir, "importer", "Dockerfile"), "w") as f:
        f.write("FROM node:10-alpine\n")
        f.write("WORKDIR /app\n")
        f.write("COPY --chown=node:node . .\n")
        f.write("RUN node --version && npm --version\n")
        f.write("RUN npm install && npm run\n")
        f.write("RUN pwd && ls -l\n")
        f.write("ENTRYPOINT [ \"npm\", \"run\" ]\n")

    subprocess.run(["docker", "build", "--progress=plain", "-t", "fluent-importer", os.path.join(repo_dir, "importer")], check=True)
    subprocess.run(["docker", "run", "--rm", "-it", "fluent-importer", "-v", "%s:/fonts" % os.path.join(repo_dir, "fonts"), "generate:svg"], check=True)


def main_fluent():
    repo_url = "https://github.com/microsoft/fluentui-system-icons"
    library = "fluent"

    repo_dir = "." + library
    assets_folder = os.path.join(repo_dir, "assets")

    pull_git_repository(repo_url, repo_dir)

    meta = {'library': library, 'output': [], 'sizes': [], 'styles': []}
    for root, dirs, files in os.walk(assets_folder):
        sizes = []
        styles = []
        for dir in dirs:
            metadata = os.path.join(root, dir, "metadata.json")
            if os.path.exists(metadata):
                with open(metadata, 'r') as file:
                    json_data = json.load(file)
                sizes += json_data.get('size')
                styles += json_data.get('style')
        print("Processing fluent")
        print(f" - sizes: {set(sizes)}")
        print(f" - styles: {set(styles)}")
        meta['sizes'].extend(set(sizes))
        meta['styles'].extend(set(styles))
        for size in set(sizes):
            for style in set(styles):
                svg_files = []
                svg_basenames = []
                for dir in dirs:
                    metadata = os.path.join(root, dir, "metadata.json")
                    if os.path.exists(metadata):
                        with open(metadata, 'r') as file:
                            json_data = json.load(file)
                        base = dir.lower().replace(' ', '_')
                        svg = os.path.join(root, dir, "SVG", f"ic_fluent_{base}_{size}_{style.lower()}.svg")
                        if os.path.exists(svg):
                            svg_files.append(svg)
                            svg_basenames.append(json_data.get('name'))

                # Sort for consistent ordering
                combined = list(zip(svg_files, svg_basenames))
                combined.sort(key=lambda x: x[1].lower())
                svg_files = [x[0] for x in combined]
                svg_basenames = [x[1] for x in combined]

                output_file_base = get_output_file_base(library, style=style.lower(), size=size)
                output_var_base = get_output_var_base(library, style=style.lower(), size=size)
                svg_contents = [extract_svg_content(svg_file) for svg_file in svg_files]
                meta['output'].extend(save_output(output_var_base, output_file_base, svg_contents, svg_basenames))

                # Generate header file for this size/style combination
                save_svg_iconlist(fluent_library_template,
                                  f"lib_fluent_{style.lower()}_{size}",
                                  {'size': size, 'style': style.lower(), 'count': len(svg_contents),
                                   'generator': os.path.basename(__file__), 'date': datetime.today().strftime('%Y-%m-%d %H:%M:%S')})

                print(f"SVG contents saved to {output_file_base}/{output_var_base}")

        break  # only top-level directories

    return meta


def main_breeze():
    repo_url = "https://github.com/KDE/breeze-icons"
    library = "breeze"

    repo_dir = "." + library

    pull_git_repository(repo_url, repo_dir)

    assets_folder = os.path.join(repo_dir, "icons")
    meta = {'library': library, 'output': [], 'sizes': [12, 16, 22, 32, 48, 64], 'styles': []}

    for root, dirs, files in os.walk(assets_folder):
        for dir in dirs:
            group = dir
            for size in meta['sizes']:
                icon_folder = os.path.join(root, dir, str(size))
                if os.path.exists(icon_folder):
                    output_file_base = get_output_file_base(library, size=size, group=group)
                    output_var_base = get_output_var_base(library, size=size, group=group)
                    svg_files = scan_for_svg_files(icon_folder)
                    # Sort files alphabetically for consistent ordering
                    svg_files.sort(key=lambda f: os.path.basename(f).lower())
                    svg_contents = [extract_svg_content(svg_file) for svg_file in svg_files]
                    svg_basenames = [os.path.splitext(os.path.basename(svg_file))[0] for svg_file in svg_files]
                    meta['output'].extend(save_output(output_var_base, output_file_base, svg_contents, svg_basenames))

                    # Generate header file for this group/size combination
                    save_svg_iconlist(breeze_library_template,
                                      f"lib_breeze_{group}_{size}",
                                      {'size': size, 'group': group, 'count': len(svg_contents),
                                       'generator': os.path.basename(__file__), 'date': datetime.today().strftime('%Y-%m-%d %H:%M:%S')})

                    print(f"SVG contents saved to {output_file_base}")

        break  # only top-level directories

    return meta


def scan_for_png_files(icon_folder):
    """Scan for PNG files, excluding symlinks and alias files.

    Returns: (real_files, aliases) where aliases is a list of (alias_name, target_name) tuples
    """
    png_files = []
    aliases = []

    for root, dirs, files in os.walk(icon_folder):
        for file in files:
            if file.endswith(".png"):
                full_path = os.path.join(root, file)
                # Skip symlinks
                if os.path.islink(full_path):
                    continue
                # Check for small files that are symlinks stored as text
                # (ZIP archives store symlinks as text files with target path)
                file_size = os.path.getsize(full_path)
                if file_size < 100:
                    # Read the target from the alias file
                    try:
                        with open(full_path, 'r') as f:
                            target = f.read().strip()
                        # Get relative paths for alias and target
                        rel_dir = os.path.dirname(os.path.relpath(full_path, icon_folder))
                        alias_name = os.path.splitext(file)[0]
                        if rel_dir:
                            alias_name = f"{rel_dir}/{alias_name}"
                        # Resolve the target relative to the alias location
                        alias_dir = os.path.dirname(full_path)
                        target_path = os.path.normpath(os.path.join(alias_dir, target))
                        target_rel = os.path.relpath(target_path, icon_folder)
                        target_name = os.path.splitext(target_rel)[0]
                        # Normalize path separators
                        alias_name = alias_name.replace('\\', '/')
                        target_name = target_name.replace('\\', '/')
                        aliases.append((alias_name, target_name))
                    except Exception as e:
                        print(f"    Warning: Could not read alias {full_path}: {e}")
                    continue
                png_files.append(full_path)
    return png_files, aliases


def find_rcc_tool():
    """Find the Qt rcc tool."""
    # Try common locations
    paths = [
        "/Users/piecuchp/Qt/6.8-static/clang_64/libexec/rcc",
        "/usr/local/Qt/6.8/bin/rcc",
        "rcc",  # Hope it's in PATH
    ]
    for path in paths:
        if os.path.exists(path) or shutil.which(path):
            return path
    raise RuntimeError("Could not find Qt rcc tool")


def process_oxygen_collection(bitmap_dir, collection_name, display_name, source_url, rcc_name):
    """Process a single Oxygen icon collection."""
    print(f"Processing {display_name} bitmap icons...")

    zip_filename = f"{collection_name}-master.zip"
    zip_path = os.path.join(bitmap_dir, zip_filename)

    if not download_file(source_url, zip_path):
        print(f"  Failed to download {display_name} icons, skipping")
        return None

    # Extract if needed
    source_dir = extract_zip(zip_path, bitmap_dir)

    # Available sizes in Oxygen icons
    available_sizes = [16, 22, 32, 48, 64, 128, 256]
    sizes_list = ", ".join(str(s) for s in available_sizes)

    # Categories to include
    categories = ['actions', 'apps', 'categories', 'devices', 'emblems',
                  'emotes', 'mimetypes', 'places', 'status']

    rcc_tool = find_rcc_tool()
    meta = {'collection': collection_name, 'output': [], 'sizes': [], 'rcc_file': None}

    # Collect all icons from all sizes for the combined QRC
    all_qrc_entries = []
    size_icon_data = {}

    for size in available_sizes:
        size_dir = os.path.join(source_dir, f"{size}x{size}")
        if not os.path.exists(size_dir):
            print(f"  Size {size}x{size} not found, skipping")
            continue

        print(f"  Processing size {size}x{size}...")

        # Collect all PNG files with their relative paths
        png_files = []
        all_aliases = []

        for category in categories:
            cat_dir = os.path.join(size_dir, category)
            if os.path.exists(cat_dir):
                files, aliases = scan_for_png_files(cat_dir)
                for f in files:
                    name = os.path.splitext(os.path.basename(f))[0]
                    # Use category/name as unique identifier
                    unique_name = f"{category}/{name}"
                    png_files.append((f, unique_name))
                # Prefix aliases with category
                for alias, target in aliases:
                    all_aliases.append((f"{category}/{alias}", f"{category}/{target}"))

        if not png_files:
            print(f"    No icons found for size {size}")
            continue

        # Sort by name
        png_files.sort(key=lambda x: x[1].lower())
        png_names = [x[1] for x in png_files]

        print(f"    Found {len(png_files)} icons")

        meta['sizes'].append(size)
        size_icon_data[size] = (png_files, png_names)

        # Add to combined QRC entries
        for png_path, name in png_files:
            abs_path = os.path.abspath(png_path)
            all_qrc_entries.append((size, name, abs_path))

        # Generate C file with icon names and aliases
        c_file = os.path.join(bitmap_dir, f"png_{collection_name}_size_{size}.c")
        with open(c_file, 'w') as f:
            f.write('#include <stddef.h>\n\n')
            f.write(f'const char* png_{collection_name}_size_{size}[] = {{\n')
            for name in png_names:
                f.write(f'    "{name}",\n')
            f.write('    NULL\n')
            f.write('};\n\n')

            # Write alias data
            f.write(f'const char* png_{collection_name}_size_{size}_aliases[][2] = {{\n')
            for alias, target in all_aliases:
                f.write(f'    {{"{alias}", "{target}"}},\n')
            f.write('    {NULL, NULL}\n')
            f.write('};\n\n')
            f.write(f'const int png_{collection_name}_size_{size}_alias_count = {len(all_aliases)};\n')
        meta['output'].append(c_file)

        print(f"    Found {len(all_aliases)} aliases")

        # Generate header file
        save_svg_iconlist(oxygen_library_template,
                          os.path.join(bitmap_dir, f"lib_{collection_name}_{size}"),
                          {'size': size, 'count': len(png_names), 'sizes_list': sizes_list,
                           'collection': collection_name, 'display_name': display_name,
                           'rcc_name': rcc_name,
                           'generator': os.path.basename(__file__),
                           'date': datetime.today().strftime('%Y-%m-%d %H:%M:%S')})

        print(f"    Generated lib_{collection_name}_{size}.h with {len(png_names)} icons")

    # Generate combined QRC file for all sizes
    if all_qrc_entries:
        qrc_file = os.path.join(bitmap_dir, f"{rcc_name}.qrc")
        with open(qrc_file, 'w') as f:
            f.write('<RCC>\n')
            # Group by size
            current_size = None
            for size, name, abs_path in sorted(all_qrc_entries, key=lambda x: (x[0], x[1].lower())):
                if current_size != size:
                    if current_size is not None:
                        f.write('</qresource>\n')
                    f.write(f'<qresource prefix="/{collection_name}/{size}">\n')
                    current_size = size
                f.write(f'    <file alias="{name}.png">{abs_path}</file>\n')
            if current_size is not None:
                f.write('</qresource>\n')
            f.write('</RCC>\n')

        # Compile to single RCC file
        rcc_file = os.path.join(bitmap_dir, f"{rcc_name}.rcc")
        print(f"  Compiling combined {rcc_file}...")
        try:
            subprocess.run([rcc_tool, "--binary", "-o", rcc_file, qrc_file],
                          check=True, capture_output=True)
            meta['rcc_file'] = rcc_file
            print(f"  Generated {rcc_file}")

            # Clean up extracted folder after RCC is generated
            if os.path.exists(source_dir):
                print(f"  Cleaning up extracted folder: {source_dir}")
                shutil.rmtree(source_dir)
        except subprocess.CalledProcessError as e:
            print(f"  Failed to compile RCC: {e.stderr.decode() if e.stderr else e}")

    return meta


def main_oxygen():
    """Process Oxygen bitmap icon collections."""
    bitmap_dir = "bitmap"
    if not os.path.exists(bitmap_dir):
        os.makedirs(bitmap_dir)

    # Process both Oxygen collections
    collections = [
        {
            'name': 'oxygen',
            'display_name': 'Oxygen',
            'url': 'https://github.com/KDE/oxygen-icons/archive/refs/heads/master.zip',
            'rcc_name': 'oxygen'
        },
        {
            'name': 'oxygen5',
            'display_name': 'Oxygen5',
            'url': 'https://github.com/KDE/oxygen-icons5/archive/refs/heads/master.zip',
            'rcc_name': 'oxygen5'
        }
    ]

    all_meta = {'library': 'oxygen', 'output': [], 'sizes': [], 'rcc_files': [], 'collections': []}

    for coll in collections:
        meta = process_oxygen_collection(
            bitmap_dir,
            coll['name'],
            coll['display_name'],
            coll['url'],
            coll['rcc_name']
        )
        if meta:
            all_meta['collections'].append(meta)
            all_meta['output'].extend(meta['output'])
            if meta['rcc_file']:
                all_meta['rcc_files'].append(meta['rcc_file'])
            # Merge sizes
            for size in meta['sizes']:
                if size not in all_meta['sizes']:
                    all_meta['sizes'].append(size)

    all_meta['sizes'].sort()
    return all_meta


if __name__ == "__main__":
    # cleanup before generation
    print("Cleanup ...")
    content = 'content'
    if os.path.exists(content):
        shutil.rmtree(content)
    os.mkdir(content)
    for f in glob.glob("*.c"):
        os.remove(f)
    output = []
    output.append(main_breeze())
    output.append(main_bootstrap())
    output.append(main_tabler())
    output.append(main_fluent())

    # Process bitmap collections (Oxygen icons)
    bitmap_output = main_oxygen()
    with open("library.pri", 'w') as file:
        file.write("RESOURCES += library/library.qrc \n")
        file.write("SOURCES += \\\n")
        for m in output:
            for f in m['output']:
                file.write(f"    library/{f}\\\n")
        # Add bitmap C files
        for f in bitmap_output['output']:
            file.write(f"    library/{f}\\\n")
        file.write("\n")
    with open("library.qrc", 'w') as file:
        file.write('<RCC>\n')
        file.write('<qresource prefix="/svg">\n')
        for f in glob.glob(f"{content}/*.svg"):
            file.write(f"  <file>{f}</file>" + "\n")
        file.write('</qresource>\n')
        file.write('</RCC>\n')
